Latest review for PR #12 in NoahPeres/ti4-ai:

============================================================
GITHUB PR REVIEW SUMMARY
============================================================
Reviewer: coderabbitai[bot]
State: COMMENTED
Submitted: 2025-09-20T14:10:17Z
Review ID: 3249053844

REVIEW BODY:
----------------------------------------
**Actionable comments posted: 4**

<details>
<summary>üßπ Nitpick comments (7)</summary><blockquote>

<details>
<summary>src/ti4/core/game_state.py (5)</summary><blockquote>

`817-823`: **Duplicate assignments to new_planet_control_mapping ‚Äî remove noise.**

Same copy performed three times.

Apply:

```diff
-        new_planet_control_mapping = self.planet_control_mapping.copy()
-        new_planet_control_mapping = self.planet_control_mapping.copy()
         new_planet_control_tokens = {
             name: tokens.copy() for name, tokens in self.planet_control_tokens.items()
         }
-        new_planet_control_mapping = self.planet_control_mapping.copy()
+        new_planet_control_mapping = self.planet_control_mapping.copy()
```

---

`862-874`: **Avoid duplicate planets by object identity; dedupe by name.**

List membership check uses object identity; use name-based.

Apply:

```diff
-        if player_id not in new_player_planets:
-            new_player_planets[player_id] = []
-        if planet not in new_player_planets[player_id]:
-            new_player_planets[player_id].append(planet)
+        if player_id not in new_player_planets:
+            new_player_planets[player_id] = []
+        if all(p.name != planet.name for p in new_player_planets[player_id]):
+            new_player_planets[player_id].append(planet)
```

---

`886-899`: **Add player existence validation in loss API.**

Mirror gain validation for symmetry and clearer errors.

Apply:

```diff
 def lose_planet_control(self, player_id: str, planet: "Planet") -> "GameState":
     """Handle losing control of a planet according to Rule 25.
@@
-        current_controller = self.planet_control_mapping.get(planet.name)
+        if not any(p.id == player_id for p in self.players):
+            raise ValueError(f"Player {player_id} does not exist in the game")
+        current_controller = self.planet_control_mapping.get(planet.name)
```

---

`1152-1155`: **Use name-based dedupe in add_player_planet.**

Same identity issue as above.

Apply:

```diff
-        # Only add if not already present
-        if planet not in new_player_planets[player_id]:
-            new_player_planets[player_id].append(planet)
+        # Only add if not already present (by name)
+        if all(p.name != planet.name for p in new_player_planets[player_id]):
+            new_player_planets[player_id].append(planet)
```

---

`1267-1293`: **Duplicate APIs for technology; delegate to one.**

Reduce duplication by making add_player_technology_card an alias.

Apply:

```diff
 def add_player_technology_card(
     self, player_id: str, technology_card: "TechnologyCard"
 ) -> "GameState":
-    """Add a technology card to a player's technology cards.
+    """Deprecated alias; use add_player_technology().

@@
-        new_player_technology_cards = {
-            pid: cards.copy() for pid, cards in self.player_technology_cards.items()
-        }
-
-        if player_id not in new_player_technology_cards:
-            new_player_technology_cards[player_id] = []
-
-        # Only add if not already present
-        if technology_card not in new_player_technology_cards[player_id]:
-            new_player_technology_cards[player_id].append(technology_card)
-
-        return self._create_new_state(
-            player_technology_cards=new_player_technology_cards
-        )
+        return self.add_player_technology(player_id, technology_card)
```

</blockquote></details>
<details>
<summary>review_response.md (1)</summary><blockquote>

`63-66`: **Specify code fence language for test output block.**

Adds syntax hint and silences MD040.

Apply:

```diff
-```
+```text
 ======================= 1063 passed, 2 skipped in 9.22s ========================
 ```
```

</blockquote></details>
<details>
<summary>latest_review.txt (1)</summary><blockquote>

`1-9`: **Avoid committing ephemeral review artifacts.**

Consider excluding/auto-generating this report in CI to prevent churn.


If you want, I can add a .gitattributes/.gitignore update and a CI artifact upload step.

</blockquote></details>

</blockquote></details>

<details>
<summary>üìú Review details</summary>

**Configuration used**: CodeRabbit UI

**Review profile**: CHILL

**Plan**: Pro

<details>
<summary>üì• Commits</summary>

Reviewing files that changed from the base of the PR and between 2e8fe37486838a0db4cd9a5357b8a2df25bbd076 and 39a0ad181ca811563920b7bc8d65d965e15030db.

</details>

<details>
<summary>üìí Files selected for processing (7)</summary>

* `.trae/lrr_analysis/executive_summary.md` (1 hunks)
* `latest_review.txt` (1 hunks)
* `review_response.md` (1 hunks)
* `src/ti4/core/game_state.py` (7 hunks)
* `src/ti4/core/planet_card.py` (1 hunks)
* `src/ti4/core/strategy_cards/coordinator.py` (1 hunks)
* `tests/test_rule_25_control.py` (1 hunks)

</details>

<details>
<summary>üöß Files skipped from review as they are similar to previous changes (2)</summary>

* tests/test_rule_25_control.py
* src/ti4/core/strategy_cards/coordinator.py

</details>

<details>
<summary>üß∞ Additional context used</summary>

<details>
<summary>üß¨ Code graph analysis (1)</summary>

<details>
<summary>src/ti4/core/game_state.py (3)</summary><blockquote>

<details>
<summary>src/ti4/core/planet_card.py (3)</summary>

* `PlanetCard` (6-88)
* `is_exhausted` (25-27)
* `exhaust` (33-37)

</details>
<details>
<summary>src/ti4/core/strategy_cards/coordinator.py (2)</summary>

* `get_player_strategy_card_assignments` (987-995)
* `get_exhausted_cards` (997-1008)

</details>
<details>
<summary>src/ti4/core/planet.py (3)</summary>

* `Planet` (9-90)
* `is_exhausted` (33-35)
* `exhaust` (41-45)

</details>

</blockquote></details>

</details><details>
<summary>ü™õ markdownlint-cli2 (0.18.1)</summary>

<details>
<summary>review_response.md</summary>

9-9: Emphasis used instead of a heading

(MD036, no-emphasis-as-heading)

---

15-15: Emphasis used instead of a heading

(MD036, no-emphasis-as-heading)

---

21-21: Emphasis used instead of a heading

(MD036, no-emphasis-as-heading)

---

27-27: Emphasis used instead of a heading

(MD036, no-emphasis-as-heading)

---

33-33: Emphasis used instead of a heading

(MD036, no-emphasis-as-heading)

---

39-39: Emphasis used instead of a heading

(MD036, no-emphasis-as-heading)

---

45-45: Emphasis used instead of a heading

(MD036, no-emphasis-as-heading)

---

53-53: Emphasis used instead of a heading

(MD036, no-emphasis-as-heading)

---

64-64: Fenced code blocks should have a language specified

(MD040, fenced-code-language)

</details>

</details>

</details>

<details>
<summary>üîá Additional comments (4)</summary><blockquote>

<details>
<summary>src/ti4/core/planet_card.py (1)</summary><blockquote>

`12-17`: **Constructor validation ‚Äî good coverage.**

Non-empty name and non-negative ints checks are correct.

</blockquote></details>
<details>
<summary>src/ti4/core/game_state.py (2)</summary><blockquote>

`14-17`: **Import path for coordinator ‚Äî correct now.**

TYPE_CHECKING path uses strategy_cards.coordinator; aligns with package layout.

---

`974-981`: **Deterministic controller selection ‚Äî LGTM.**

Initiative-ordered tie-break removes nondeterminism.

</blockquote></details>
<details>
<summary>.trae/lrr_analysis/executive_summary.md (1)</summary><blockquote>

`3-6`: **Headline metrics contradict roadmap; regenerate or drop until automated.**

‚Äú107/101 rules‚Äù and ‚Äú3.5%‚Äù don‚Äôt match IMPLEMENTATION_ROADMAP.md.



```shell
#!/bin/bash
# Cross-check key claims against roadmap
rg -n "Total Rules Analyzed|Overall Implementation Progress" .trae/lrr_analysis/executive_summary.md
rg -n "Overall Progress|Completed Rules" IMPLEMENTATION_ROADMAP.md
```

</blockquote></details>

</blockquote></details>

</details>

<!-- This is an auto-generated comment by CodeRabbit for review status -->

DETAILED COMMENTS:
----------------------------------------
Comment 1:
  File: src/ti4/core/game_state.py
  Line: 116
  Body: _‚ö†Ô∏è Potential issue_

**Add player existence validation in control APIs.**

Gain control should reject unknown player IDs (consistency with award_victory_points).

Apply:

```diff
 def gain_planet_control(
     self, player_id: str, planet: "Planet"
 ) -> tuple[bool, "GameState"]:
     """Handle gaining control of a planet according to Rule 25.
@@
-        # Rule 25.2: Cannot gain control of already controlled planet
+        # Validate player exists
+        if not any(p.id == player_id for p in self.players):
+            raise ValueError(f"Player {player_id} does not exist in the game")
+
+        # Rule 25.2: Cannot gain control of already controlled planet
         current_controller = self.planet_control_mapping.get(planet.name)
         if current_controller == player_id:
             raise ValueError("Player already controls this planet")
```

<!-- suggestion_start -->

<details>
<summary>üìù Committable suggestion</summary>

> ‚ÄºÔ∏è **IMPORTANT**
> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.

```suggestion
    def gain_planet_control(
        self, player_id: str, planet: "Planet"
    ) -> tuple[bool, "GameState"]:
        """Handle gaining control of a planet according to Rule 25.

        Args:
            player_id: The player gaining control
            planet: The planet being controlled

        Returns:
            Tuple of (exploration_triggered, new_game_state)
            exploration_triggered: True if exploration should be triggered (first control)

        Raises:
            ValueError: If player already controls this planet (Rule 25.2)
        """
        # Validate player exists
        if not any(p.id == player_id for p in self.players):
            raise ValueError(f"Player {player_id} does not exist in the game")

        # Rule 25.2: Cannot gain control of already controlled planet
        current_controller = self.planet_control_mapping.get(planet.name)
        if current_controller == player_id:
            raise ValueError("Player already controls this planet")
```

</details>

<!-- suggestion_end -->

<details>
<summary>ü§ñ Prompt for AI Agents</summary>

```
In src/ti4/core/game_state.py around lines 785 to 805, the gain_planet_control
method lacks validation that the supplied player_id exists; add the same player
existence check used by award_victory_points so unknown player IDs are rejected.
Specifically, before checking current controller, verify player_id is present in
self.players (or the canonical player collection on GameState) and raise
ValueError("Unknown player id") (or a matching error message used elsewhere) if
not found; keep the existing Rule 25.2 check and return semantics unchanged.
```

</details>

<!-- fingerprinting:phantom:poseidon:chinchilla -->

<!-- This is an auto-generated comment by CodeRabbit -->

Comment 2:
  File: src/ti4/core/game_state.py
  Line: 160
  Body: _‚ö†Ô∏è Potential issue_

**Immutability breach: mutates shared PlanetCard instance across states.**

Exhausting planet_card here mutates the object that also exists in the previous GameState (deck/other player), breaking snapshot semantics of frozen GameState.

Apply:

```diff
-        if player_id not in new_player_planet_cards:
-            new_player_planet_cards[player_id] = []
-        new_player_planet_cards[player_id].append(planet_card)
-
-        # Rule 25.1: Card is exhausted when gained
-        if not planet_card.is_exhausted():
-            planet_card.exhaust()
+        if player_id not in new_player_planet_cards:
+            new_player_planet_cards[player_id] = []
+        # Create a fresh instance to avoid mutating prior-state references
+        card_copy = type(planet_card)(
+            planet_card.name,
+            planet_card.resources,
+            planet_card.influence,
+            trait=getattr(planet_card, "trait", None),
+        )
+        if not card_copy.is_exhausted():
+            card_copy.exhaust()
+        new_player_planet_cards[player_id].append(card_copy)
```

<!-- suggestion_start -->

<details>
<summary>üìù Committable suggestion</summary>

> ‚ÄºÔ∏è **IMPORTANT**
> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.

```suggestion
        # Add to new player's play area
        if player_id not in new_player_planet_cards:
            new_player_planet_cards[player_id] = []
        # Create a fresh instance to avoid mutating prior-state references
        card_copy = type(planet_card)(
            planet_card.name,
            planet_card.resources,
            planet_card.influence,
            trait=getattr(planet_card, "trait", None),
        )
        if not card_copy.is_exhausted():
            card_copy.exhaust()
        new_player_planet_cards[player_id].append(card_copy)
```

</details>

<!-- suggestion_end -->

<details>
<summary>ü§ñ Prompt for AI Agents</summary>

```
In src/ti4/core/game_state.py around lines 838 to 846, the code exhausts the
existing planet_card instance which mutates an object shared with the previous
GameState; instead, create a new PlanetCard instance (via the class's
copy/clone/factory method or a shallow/deep copy) representing the gained card,
set/exhaust that new instance, and append the new exhausted instance to
new_player_planet_cards[player_id] so the original planet_card in the old state
remains unchanged and snapshot immutability is preserved.
```

</details>

<!-- fingerprinting:phantom:poseidon:chinchilla -->

<!-- This is an auto-generated comment by CodeRabbit -->

Comment 3:
  File: src/ti4/core/planet_card.py
  Line: 62
  Body: _‚ö†Ô∏è Potential issue_

**Validate spend amount type and positivity; clarify errors.**

Currently allows 0/negative or non-int amounts and raises late. Tighten upfront.

Apply:

```diff
 def spend_resources(self, amount: int) -> int:
-    """Spend resources from this planet card, exhausting it."""
-    if self._exhausted:
+    """Spend resources from this planet card, exhausting it."""
+    if not isinstance(amount, int) or amount <= 0:
+        raise ValueError("Spend amount must be a positive integer")
+    if self._exhausted:
         raise ValueError("Cannot spend from exhausted planet card")
     if amount > self.resources:
         raise ValueError(
             f"Cannot spend {amount} resources, planet card only has {self.resources}"
         )

     self.exhaust()
     return amount
```

<!-- suggestion_start -->

<details>
<summary>üìù Committable suggestion</summary>

> ‚ÄºÔ∏è **IMPORTANT**
> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.

```suggestion
    def spend_resources(self, amount: int) -> int:
        """Spend resources from this planet card, exhausting it."""
        if not isinstance(amount, int) or amount <= 0:
            raise ValueError("Spend amount must be a positive integer")
        if self._exhausted:
            raise ValueError("Cannot spend from exhausted planet card")
        if amount > self.resources:
            raise ValueError(
                f"Cannot spend {amount} resources, planet card only has {self.resources}"
            )

        self.exhaust()
        return amount
```

</details>

<!-- suggestion_end -->

<details>
<summary>ü§ñ Prompt for AI Agents</summary>

```
In src/ti4/core/planet_card.py around lines 51 to 62, validate that amount is an
integer and strictly positive before any other checks: first check
isinstance(amount, int) and reject bools, raising a TypeError with a clear
message if not an int; then check amount > 0 and raise a ValueError with a clear
message if not positive; only after those validations, check for self._exhausted
and raise the existing ValueError if exhausted; keep the rest of the logic
(exhaust and return amount) unchanged.
```

</details>

<!-- fingerprinting:phantom:poseidon:chinchilla -->

<!-- This is an auto-generated comment by CodeRabbit -->

Comment 4:
  File: src/ti4/core/planet_card.py
  Line: 74
  Body: _‚ö†Ô∏è Potential issue_

**Mirror spend validation for influence.**

Same input validation gap as resources.

Apply:

```diff
 def spend_influence(self, amount: int) -> int:
-    """Spend influence from this planet card, exhausting it."""
-    if self._exhausted:
+    """Spend influence from this planet card, exhausting it."""
+    if not isinstance(amount, int) or amount <= 0:
+        raise ValueError("Spend amount must be a positive integer")
+    if self._exhausted:
         raise ValueError("Cannot spend from exhausted planet card")
     if amount > self.influence:
         raise ValueError(
             f"Cannot spend {amount} influence, planet card only has {self.influence}"
         )

     self.exhaust()
     return amount
```

<!-- suggestion_start -->

<details>
<summary>üìù Committable suggestion</summary>

> ‚ÄºÔ∏è **IMPORTANT**
> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.

```suggestion
    def spend_influence(self, amount: int) -> int:
        """Spend influence from this planet card, exhausting it."""
        if not isinstance(amount, int) or amount <= 0:
            raise ValueError("Spend amount must be a positive integer")
        if self._exhausted:
            raise ValueError("Cannot spend from exhausted planet card")
        if amount > self.influence:
            raise ValueError(
                f"Cannot spend {amount} influence, planet card only has {self.influence}"
            )

        self.exhaust()
        return amount
```

</details>

<!-- suggestion_end -->

<details>
<summary>ü§ñ Prompt for AI Agents</summary>

```
In src/ti4/core/planet_card.py around lines 63 to 74, the spend_influence method
lacks the same input validation used by the resources counterpart; update it to
mirror that validation by checking that amount is a positive integer (e.g.,
amount > 0) and raising a ValueError for non-positive amounts, ensure you still
check amount <= self.influence and raise the existing ValueError when exceeding
available influence, then deduct the influence (or otherwise consume it as
resources does), call self.exhaust(), and return the spent amount.
```

</details>

<!-- fingerprinting:phantom:poseidon:chinchilla -->

<!-- This is an auto-generated comment by CodeRabbit -->

============================================================
