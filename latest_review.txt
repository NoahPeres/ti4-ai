Latest review for PR #13 in NoahPeres/ti4-ai:

============================================================
GITHUB PR REVIEW SUMMARY
============================================================
Reviewer: coderabbitai[bot]
State: COMMENTED
Submitted: 2025-09-21T01:13:33Z
Review ID: 3249329778

REVIEW BODY:
----------------------------------------
**Actionable comments posted: 2**

<details>
<summary>üßπ Nitpick comments (15)</summary><blockquote>

<details>
<summary>.trae/lrr_analysis/21_commodities.md (3)</summary><blockquote>

`7-21`: **Add language to fenced code block (markdownlint MD040).**

Declare the code block language for the raw LRR excerpt.

Apply this diff:

```diff
-```
+```text
 ...
-```
+```
```

---

`15-17`: **Replace hard tabs with spaces (markdownlint MD010).**

Tabs appear before items a/b/c; use spaces for indentation.

Apply this diff:

```diff
-a	That token is no longer a commodity token; it is a trade good token.
-b  A player can trade commodity tokens before resolving a game effect that allows them to replenish commodities.
-c	If a game effect instructs a player to convert a number of their own commodities to trade goods, those trade goods are not treated as being gained for the purpose of triggering other abilities.
+a  That token is no longer a commodity token; it is a trade good token.
+b  A player can trade commodity tokens before resolving a game effect that allows them to replenish commodities.
+c  If a game effect instructs a player to convert a number of their own commodities to trade goods, those trade goods are not treated as being gained for the purpose of triggering other abilities.
```

---

`67-73`: **Doc/tests mismatch: missing ‚Äúcannot give more than owned‚Äù test.**

This section lists a test that doesn‚Äôt exist in tests/test_rule_21_commodity_trading.py. Add the test or update docs.

</blockquote></details>
<details>
<summary>src/ti4/core/faction_data.py (2)</summary><blockquote>

`11-24`: **Make COMMODITY_VALUES immutable and typed.**

Prevent accidental mutation and improve type safety with Final + MappingProxyType.

Apply this diff:

```diff
-from .constants import Faction
+from .constants import Faction
+from typing import Final, Mapping
+from types import MappingProxyType
@@
-    COMMODITY_VALUES = {
+    COMMODITY_VALUES: Final[Mapping[Faction, int]] = MappingProxyType({
         Faction.SOL: 4,
         Faction.HACAN: 6,  # Trade-focused faction
         Faction.XXCHA: 4,
         Faction.JORD: 4,
         Faction.YSSARIL: 3,
         Faction.NAALU: 3,
         Faction.BARONY: 2,
         Faction.SAAR: 3,
         Faction.MUAAT: 4,
         Faction.ARBOREC: 3,
         Faction.L1Z1X: 2,
         Faction.WINNU: 3,
-    }
+    })
```

---

`39-41`: **Minor: simplify lookup.**

Use dict get with explicit error to reduce double indexing.

Apply this diff:

```diff
-        if faction not in cls.COMMODITY_VALUES:
-            raise ValueError(f"Unknown faction: {faction}")
-        return cls.COMMODITY_VALUES[faction]
+        value = cls.COMMODITY_VALUES.get(faction)
+        if value is None:
+            raise ValueError(f"Unknown faction: {faction}")
+        return value
```

</blockquote></details>
<details>
<summary>IMPLEMENTATION_ROADMAP.md (1)</summary><blockquote>

`91-119`: **Add fenced code languages for linting/readability.**

Many code blocks use bare ```; prefer ```text or specific languages.


I can open a follow‚Äëup PR adding languages to all fenced blocks.


Also applies to: 121-148, 204-246, 336-365, 566-599, 656-673, 970-1010, 1025-1046, 1116-1135

</blockquote></details>
<details>
<summary>tests/test_rule_21_commodity_trading.py (2)</summary><blockquote>

`81-101`: **Consider testing negative/zero amounts for self-conversion.**

Add a small param test to ensure ValueError on invalid amounts.

---

`102-120`: **Add missing ‚Äúcannot give more than owned‚Äù test.**

Docs list this; include it here for completeness.

Apply this diff:

```diff
@@
 class TestRule21CommodityTrading:
@@
     def test_any_commodity_gift_converts_to_trade_good(self) -> None:
         ...
         assert player2.get_commodities() == 0  # Not a commodity anymore
+
+    def test_cannot_give_more_commodities_than_owned(self) -> None:
+        player1 = Player("Player1", Faction.SOL)
+        player2 = Player("Player2", Faction.HACAN)
+        player1.add_commodities(1)
+        with pytest.raises(ValueError):
+            player1.give_commodities_to_player(player2, 2)
```

</blockquote></details>
<details>
<summary>tests/test_rule_21_commodities.py (2)</summary><blockquote>

`118-124`: **Avoid hard-coded ‚Äú4‚Äù; derive from faction value.**

Prevents drift if faction data changes.

Apply this diff:

```diff
-        # Fill commodities to max
-        player.add_commodities(4)
-        assert player.get_commodities() == 4
+        # Fill commodities to max
+        max_val = player.get_commodity_value()
+        player.add_commodities(max_val)
+        assert player.get_commodities() == max_val
@@
-        assert player.get_commodities() == 4
+        assert player.get_commodities() == max_val
```

---

`53-69`: **Add negative/zero input validation tests for add_commodities.**

Covers input validation paths.

Apply this diff:

```diff
@@ class TestRule21CommodityBasics:
     def test_commodity_limit_enforcement(self) -> None:
         ...
         with pytest.raises(ValueError, match="Cannot exceed commodity limit"):
             player.add_commodities(1)
+
+    def test_add_commodities_invalid_amounts(self) -> None:
+        player = Player("TestPlayer", Faction.SOL)
+        for amt in (0, -1, -5):
+            with pytest.raises(ValueError):
+                player.add_commodities(amt)
```

</blockquote></details>
<details>
<summary>src/ti4/core/command_sheet.py (2)</summary><blockquote>

`89-104`: **Clarify zero‚Äëspend behavior (bool return).**

Current logic returns True for amount == 0. If that‚Äôs intended, consider a short note in the docstring to avoid ambiguity.


```diff
 def spend_trade_goods(self, amount: int) -> bool:
-    """Spend trade goods (Rule 93.3, 93.4)."""
+    """Spend trade goods (Rule 93.3, 93.4). Returns True for amount==0 (no-op)."""
```

---

`18-18`: **Rule numbering consistency.**

Inline comment references Rule 19.2 while methods cite Rule 93.x. Standardize numbering to the project‚Äôs LRR mapping.




Also applies to: 79-108

</blockquote></details>
<details>
<summary>src/ti4/core/player.py (3)</summary><blockquote>

`85-89`: **Reuse local API for clarity.**

Minor: call self.get_commodity_value() instead of FactionData directly.

```diff
-commodity_value = FactionData.get_commodity_value(self.faction)
+commodity_value = self.get_commodity_value()
 object.__setattr__(self, "_commodity_count", commodity_value)
```

---

`102-124`: **Handle self‚Äëgifting explicitly or disallow.**

Currently, giving to yourself reduces commodities and adds equal trade goods‚Äîfunctionally identical to convert_commodities_to_trade_goods. Make this explicit (or raise), to avoid double‚Äëprocessing if this method is extended later.

```diff
     if amount < 0:
         raise ValueError("Cannot give negative commodities")
     if self._commodity_count < amount:
         raise ValueError(
             f"Player only has {self._commodity_count} commodities, cannot give {amount}"
         )
+    # Giving to self is equivalent to conversion.
+    if other_player is self:
+        self.convert_commodities_to_trade_goods(amount)
+        return

     # Remove commodities from this player
     object.__setattr__(self, "_commodity_count", self._commodity_count - amount)

     # Convert to trade goods for the receiving player (Rule 21.5)
     other_player.gain_trade_goods(amount)
```

---

`125-143`: **DRY the commodity removal path (optional).**

Both give_commodities_to_player and convert_commodities_to_trade_goods perform the same validations and subtraction. Consider a private helper to centralize this.

```python
def _remove_commodities(self, amount: int) -> None:
    if amount < 0:
        raise ValueError("Cannot remove negative commodities")
    if self._commodity_count < amount:
        raise ValueError(
            f"Player only has {self._commodity_count} commodities, cannot remove {amount}"
        )
    object.__setattr__(self, "_commodity_count", self._commodity_count - amount)
```
Then call _remove_commodities from both methods.

</blockquote></details>

</blockquote></details>

<details>
<summary>üìú Review details</summary>

**Configuration used**: CodeRabbit UI

**Review profile**: CHILL

**Plan**: Pro

<details>
<summary>üì• Commits</summary>

Reviewing files that changed from the base of the PR and between 0d548e12ba462121a3aab614df282c8a2ff4e48c and 440e9209eeee5bdaf783a63e4416e0ed3289dbf0.

</details>

<details>
<summary>üìí Files selected for processing (7)</summary>

* `.trae/lrr_analysis/21_commodities.md` (1 hunks)
* `IMPLEMENTATION_ROADMAP.md` (1 hunks)
* `src/ti4/core/command_sheet.py` (2 hunks)
* `src/ti4/core/faction_data.py` (1 hunks)
* `src/ti4/core/player.py` (3 hunks)
* `tests/test_rule_21_commodities.py` (1 hunks)
* `tests/test_rule_21_commodity_trading.py` (1 hunks)

</details>

<details>
<summary>üß∞ Additional context used</summary>

<details>
<summary>üß¨ Code graph analysis (5)</summary>

<details>
<summary>src/ti4/core/faction_data.py (2)</summary><blockquote>

<details>
<summary>src/ti4/core/constants.py (1)</summary>

* `Faction` (124-138)

</details>
<details>
<summary>src/ti4/core/player.py (1)</summary>

* `get_commodity_value` (48-57)

</details>

</blockquote></details>
<details>
<summary>tests/test_rule_21_commodity_trading.py (3)</summary><blockquote>

<details>
<summary>src/ti4/core/constants.py (1)</summary>

* `Faction` (124-138)

</details>
<details>
<summary>src/ti4/core/player.py (7)</summary>

* `Player` (11-143)
* `replenish_commodities` (85-88)
* `get_commodities` (59-65)
* `get_trade_goods` (90-92)
* `give_commodities_to_player` (102-123)
* `add_commodities` (67-83)
* `convert_commodities_to_trade_goods` (125-143)

</details>
<details>
<summary>src/ti4/core/command_sheet.py (1)</summary>

* `get_trade_goods` (105-107)

</details>

</blockquote></details>
<details>
<summary>tests/test_rule_21_commodities.py (3)</summary><blockquote>

<details>
<summary>src/ti4/core/constants.py (1)</summary>

* `Faction` (124-138)

</details>
<details>
<summary>src/ti4/core/player.py (5)</summary>

* `Player` (11-143)
* `get_commodity_value` (48-57)
* `get_commodities` (59-65)
* `add_commodities` (67-83)
* `replenish_commodities` (85-88)

</details>
<details>
<summary>src/ti4/core/faction_data.py (1)</summary>

* `get_commodity_value` (27-41)

</details>

</blockquote></details>
<details>
<summary>src/ti4/core/player.py (3)</summary><blockquote>

<details>
<summary>src/ti4/core/command_sheet.py (4)</summary>

* `CommandSheet` (12-146)
* `get_trade_goods` (105-107)
* `gain_trade_goods` (79-87)
* `spend_trade_goods` (89-103)

</details>
<details>
<summary>src/ti4/core/constants.py (1)</summary>

* `Faction` (124-138)

</details>
<details>
<summary>src/ti4/core/faction_data.py (2)</summary>

* `FactionData` (6-41)
* `get_commodity_value` (27-41)

</details>

</blockquote></details>
<details>
<summary>src/ti4/core/command_sheet.py (1)</summary><blockquote>

<details>
<summary>src/ti4/core/player.py (3)</summary>

* `gain_trade_goods` (94-96)
* `spend_trade_goods` (98-100)
* `get_trade_goods` (90-92)

</details>

</blockquote></details>

</details><details>
<summary>ü™õ markdownlint-cli2 (0.18.1)</summary>

<details>
<summary>.trae/lrr_analysis/21_commodities.md</summary>

7-7: Fenced code blocks should have a language specified

(MD040, fenced-code-language)

---

15-15: Hard tabs
Column: 2

(MD010, no-hard-tabs)

---

17-17: Hard tabs
Column: 2

(MD010, no-hard-tabs)

</details>

</details>

</details>

<details>
<summary>üîá Additional comments (10)</summary><blockquote>

<details>
<summary>tests/test_rule_21_commodity_trading.py (2)</summary><blockquote>

`10-35`: **LGTM: conversion-on-receipt behavior covered.**

Good assertions for giver‚Äôs commodities and receiver‚Äôs trade goods.

---

`59-80`: **LGTM: trade before replenishment.**

Validates timing rule cleanly.

</blockquote></details>
<details>
<summary>tests/test_rule_21_commodities.py (1)</summary><blockquote>

`26-40`: **LGTM: verifies SOL commodity value.**

Keeps a concrete check anchored to LRR.

</blockquote></details>
<details>
<summary>src/ti4/core/faction_data.py (1)</summary><blockquote>

`1-24`: **Incorrect scope ‚Äî COMMODITY_VALUES already covers all Faction members.**
constants.py defines many non‚Äëfaction enum entries; COMMODITY_VALUES maps exactly the 12 faction members (SOL, HACAN, XXCHA, JORD, YSSARIL, NAALU, BARONY, SAAR, MUAAT, ARBOREC, L1Z1X, WINNU) and contains no extraneous keys ‚Äî no faction is missing.

> Likely an incorrect or invalid review comment.

</blockquote></details>
<details>
<summary>src/ti4/core/command_sheet.py (2)</summary><blockquote>

`18-18`: **Good addition: explicit trade goods state on CommandSheet.**

Field is well-scoped and defaults make sense.

---

`79-88`: **Input validation for gains looks solid.**

Negative amounts raise early; zero is a no-op. LGTM.

</blockquote></details>
<details>
<summary>src/ti4/core/player.py (4)</summary><blockquote>

`20-20`: **Private commodity counter on a frozen dataclass is fine.**

Pattern with object.__setattr__ matches existing reinforcements handling.

---

`48-58`: **FactionData delegation reads well.**

Keeps commodity caps centralized.

---

`59-66`: **Getter is straightforward.**

No concerns.

---

`90-101`: **Trade goods delegation is clean.**

Surface mirrors CommandSheet API; good separation.

</blockquote></details>

</blockquote></details>

</details>

<!-- This is an auto-generated comment by CodeRabbit for review status -->

DETAILED COMMENTS:
----------------------------------------
Comment 1:
  File: src/ti4/core/faction_data.py
  Line: 16
  Body: _üõ†Ô∏è Refactor suggestion_

<details>
<summary>üß© Analysis chain</summary>

**Non-canonical faction name ‚ÄúJORD‚Äù.**

TI4 uses Jol-Nar; confirm whether Faction.JORD is a placeholder. If so, plan a rename (alias + deprecation) to avoid long‚Äëterm confusion.


Run to find usages:

---

üèÅ Script executed:

```shell
#!/bin/bash
rg -n -C2 '\bJORD\b' --type=py
```

Length of output: 819

---



</details>

**Rename Faction.JORD ‚Üí Faction.JOL_NAR and add a deprecated JORD alias.**

Findings: JORD appears in src/ti4/core/constants.py (lines 130, 148) and src/ti4/core/faction_data.py (line 15). Action: add canonical enum member Faction.JOL_NAR (use the project‚Äôs slug convention for its value), update constants.py to export JOL_NAR and update faction_data.py to use Faction.JOL_NAR, then keep JORD = Faction.JOL_NAR as a backward-compatible alias with a deprecation comment and changelog/test updates.

<details>
<summary>ü§ñ Prompt for AI Agents</summary>

```
In src/ti4/core/faction_data.py around lines 15-16, replace usage of the old
enum member Faction.JORD with the new canonical Faction.JOL_NAR (use the
project's slug convention for its enum value), and in src/ti4/core/constants.py
update exports to include JOL_NAR instead of JORD; then add a
backward-compatible alias by setting JORD = Faction.JOL_NAR with a deprecation
comment pointing to the changelog, and update any tests and the changelog to
reference the new name (or note the alias) so callers are warned to migrate.
```

</details>

<!-- fingerprinting:phantom:medusa:chinchilla -->

<!-- This is an auto-generated comment by CodeRabbit -->

Comment 2:
  File: src/ti4/core/player.py
  Line: 61
  Body: _‚ö†Ô∏è Potential issue_

**Prevent negative adds and underflow in add_commodities.**

As written, passing a negative count silently subtracts commodities and can underflow below zero. Guard against negative input.

```diff
 def add_commodities(self, count: int) -> None:
     """Add commodity tokens to this player.

     Args:
-        count: Number of commodity tokens to add
+        count: Number of commodity tokens to add (must be >= 0)

     Raises:
-        ValueError: If adding would exceed commodity limit
+        ValueError: If adding would exceed commodity limit or if count is negative
     """
-    new_count = self._commodity_count + count
-    max_commodities = self.get_commodity_value()
+    if count < 0:
+        raise ValueError("Cannot add negative commodities")
+    new_count = self._commodity_count + count
+    max_commodities = self.get_commodity_value()

     if new_count > max_commodities:
         raise ValueError(f"Cannot exceed commodity limit of {max_commodities}")

     # Since this is a frozen dataclass, we need to modify the field directly
     object.__setattr__(self, "_commodity_count", new_count)
```

<!-- suggestion_start -->

<details>
<summary>üìù Committable suggestion</summary>

> ‚ÄºÔ∏è **IMPORTANT**
> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.

```suggestion
    def add_commodities(self, count: int) -> None:
        """Add commodity tokens to this player.

        Args:
            count: Number of commodity tokens to add (must be >= 0)

        Raises:
            ValueError: If adding would exceed commodity limit or if count is negative
        """
        if count < 0:
            raise ValueError("Cannot add negative commodities")
        new_count = self._commodity_count + count
        max_commodities = self.get_commodity_value()

        if new_count > max_commodities:
            raise ValueError(f"Cannot exceed commodity limit of {max_commodities}")

        # Since this is a frozen dataclass, we need to modify the field directly
        object.__setattr__(self, "_commodity_count", new_count)
```

</details>

<!-- suggestion_end -->

<details>
<summary>ü§ñ Prompt for AI Agents</summary>

```
In src/ti4/core/player.py around lines 67 to 84, add input validation to prevent
negative commodity changes: before computing new_count, check if count is
negative and raise a ValueError (e.g., "count must be non-negative") or
alternatively after computing new_count ensure new_count >= 0 and raise a
ValueError if it would go below zero; keep the existing check against exceeding
get_commodity_value() and retain the object.__setattr__ update for the frozen
dataclass.
```

</details>

<!-- fingerprinting:phantom:poseidon:chinchilla -->

<!-- This is an auto-generated comment by CodeRabbit -->

============================================================
