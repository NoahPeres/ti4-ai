Latest review for PR #12 in NoahPeres/ti4-ai:

============================================================
GITHUB PR REVIEW SUMMARY
============================================================
Reviewer: coderabbitai[bot]
State: COMMENTED
Submitted: 2025-09-20T10:04:53Z
Review ID: 3248971528

REVIEW BODY:
----------------------------------------
**Actionable comments posted: 3**

> [!CAUTION]
> Some comments are outside the diff and can‚Äôt be posted inline due to platform limitations.
>
>
>
> <details>
> <summary>‚ö†Ô∏è Outside diff range comments (1)</summary><blockquote>
>
> <details>
> <summary>src/ti4/core/game_state.py (1)</summary><blockquote>
>
> `1-4`: **Fix: frozen GameState mutates external Planet objects**
>
> GameState is declared @dataclass(frozen=True) but its methods mutate Planet instances, breaking immutability/snapshot semantics.
>
> - Evidence (locations): src/ti4/core/game_state.py @dataclass(frozen=True) (line 33); gain_planet_control calls Planet.set_control (see game_state around line ~795 ‚Äî Planet.set_control defined src/ti4/core/planet.py:22); lose_planet_control assigns planet.controlled_by = None (src/ti4/core/game_state.py:890); external readers/mutators: src/ti4/core/production_ability.py:296 and tests/test_planet.py:25-26.
>
> Action: either stop mutating Planet objects (clone/return new Planet instances when producing a new GameState) or centralize/own control state inside GameState (use mappings like player_planets/planet_control_tokens) and make Planet immutable.
>
> </blockquote></details>
>
> </blockquote></details>

<details>
<summary>üßπ Nitpick comments (11)</summary><blockquote>

<details>
<summary>.trae/lrr_analysis/executive_summary.md (1)</summary><blockquote>

`66-76`: **Contradicts codebase status (e.g., Neighbors, Objectives, Wormholes at 0%).**

Roadmap and tests indicate these are implemented. Please reconcile the table with reality.

</blockquote></details>
<details>
<summary>src/ti4/core/strategy_cards/coordinator.py (1)</summary><blockquote>

`166-167`: **Remove unused `_exhausted_cards` field to avoid confusion.**

All exhaustion state is sourced from `_player_card_states`; `_exhausted_cards` is never read.

```diff
-        self._exhausted_cards: set[StrategyCardType] = set()
...
-        self._exhausted_cards = set()
```


Also applies to: 874-875

</blockquote></details>
<details>
<summary>tests/test_rule_25_control.py (3)</summary><blockquote>

`18-43`: **Assert exploration flag in first-control test.**

You already return `exploration_triggered`; assert it here for tighter coverage.

```diff
-        exploration_triggered, new_state = game_state.gain_planet_control(
+        exploration_triggered, new_state = game_state.gain_planet_control(
             "player1", planet
         )
+        assert exploration_triggered
```

---

`183-212`: **Add explicit controller assertions for clarity.**

After resolution, also assert `planet.controlled_by == "player2"` to couple board state and card state.

```diff
         assert len(player2_cards) == 1
         assert player2_cards[0].name == "Contested Planet"
+        assert planet.controlled_by == "player2"
```

---

`247-259`: **Mark placeholders as skipped to avoid false greens.**

Use `@pytest.mark.skip(reason="pending invasion/exploration mechanics")`.

```diff
-    def test_control_integration_with_invasion(self) -> None:
+    @pytest.mark.skip(reason="pending invasion mechanics")
+    def test_control_integration_with_invasion(self) -> None:
...
-    def test_control_integration_with_exploration(self) -> None:
+    @pytest.mark.skip(reason="pending exploration mechanics")
+    def test_control_integration_with_exploration(self) -> None:
```

</blockquote></details>
<details>
<summary>src/ti4/core/planet_card.py (1)</summary><blockquote>

`9-17`: **Validate inputs for name/resources/influence.**

Prevents invalid cards entering state.

```diff
     def __init__(
         self, name: str, resources: int, influence: int, trait: Optional[str] = None
     ) -> None:
-        self.name = name
+        if not isinstance(name, str) or not name.strip():
+            raise ValueError("PlanetCard.name must be a non-empty string")
+        if not isinstance(resources, int) or resources < 0:
+            raise ValueError("PlanetCard.resources must be a non-negative int")
+        if not isinstance(influence, int) or influence < 0:
+            raise ValueError("PlanetCard.influence must be a non-negative int")
+        self.name = name
         self.resources = resources
         self.influence = influence
         self.trait = trait
         self._exhausted = False
```

</blockquote></details>
<details>
<summary>.trae/lrr_analysis/25_control.md (1)</summary><blockquote>

`47-51`: **Test names in docs don‚Äôt match code.**

Docs list `test_rule_25_1b_subsequent_control_takes_from_player`; code uses `test_rule_25_1b_control_transfer_takes_from_other_player`. Align names to reduce confusion.

</blockquote></details>
<details>
<summary>src/ti4/core/game_state.py (4)</summary><blockquote>

`777-853`: **Keep `player_planets` mapping consistent and avoid in-place planet mutation.**

You mutate `planet` (external) but don‚Äôt update `player_planets`. Update both removal/addition; prefer not mutating external objects in-place.

```diff
-        # Update planet control
-        planet.set_control(player_id)
+        # Update planet control (avoid mutating external instance if tracked elsewhere)
+        planet.set_control(player_id)
+
+        # Maintain player_planets mapping
+        new_player_planets = {pid: planets.copy() for pid, planets in self.player_planets.items()}
+        # Remove from previous controller
+        if planet.controlled_by and planet.controlled_by in new_player_planets:
+            new_player_planets[planet.controlled_by] = [p for p in new_player_planets[planet.controlled_by] if p.name != planet.name]
+        # Add to new controller
+        if player_id not in new_player_planets:
+            new_player_planets[player_id] = []
+        if all(p.name != planet.name for p in new_player_planets[player_id]):
+            new_player_planets[player_id].append(planet)
...
-        new_state = self._create_new_state(
+        new_state = self._create_new_state(
             planet_card_deck=new_planet_card_deck,
             player_planet_cards=new_player_planet_cards,
             planet_control_tokens=new_planet_control_tokens,
+            player_planets=new_player_planets,
         )
```

---

`854-896`: **Also update `player_planets` on loss.**

Keep mappings in sync when control is lost.

```diff
-        # Clear planet control
-        planet.controlled_by = None
+        # Clear planet control
+        planet.controlled_by = None
+
+        # Update player_planets mapping
+        new_player_planets = {pid: planets.copy() for pid, planets in self.player_planets.items()}
+        if player_id in new_player_planets:
+            new_player_planets[player_id] = [p for p in new_player_planets[player_id] if p.name != planet.name]
...
-        return self._create_new_state(
+        return self._create_new_state(
             player_planet_cards=new_player_planet_cards,
             planet_control_tokens=new_planet_control_tokens,
+            player_planets=new_player_planets,
         )
```

---

`612-633`: **Duplicate shuffle methods (`shuffle_secret_objective_deck` vs `shuffle_secret_objectives`).**

Consolidate to one name; keep the other as a thin alias for backward compatibility.

```diff
-    def shuffle_secret_objectives(self) -> "GameState":
-        """Shuffle the secret objective deck.
-
-        Returns:
-            New GameState with shuffled secret objective deck
-        """
-        import random
-
-        new_deck = self.secret_objective_deck.copy()
-        random.shuffle(new_deck)
-        return self._create_new_state(secret_objective_deck=new_deck)
+    def shuffle_secret_objectives(self) -> "GameState":
+        """Deprecated alias; use shuffle_secret_objective_deck()."""
+        return self.shuffle_secret_objective_deck()
```


Also applies to: 1117-1127

---

`1109-1116`: **Secret objective helpers ‚Äî minor polish.**

Consider naming consistency: ‚Äúdeck‚Äù suffix for all deck-oriented methods.



Also applies to: 1257-1270

</blockquote></details>

</blockquote></details>

<details>
<summary>üìú Review details</summary>

**Configuration used**: CodeRabbit UI

**Review profile**: CHILL

**Plan**: Pro

<details>
<summary>üì• Commits</summary>

Reviewing files that changed from the base of the PR and between 1bc070cb716fd754d6a065d31dfef4f937a66765 and 2e8fe37486838a0db4cd9a5357b8a2df25bbd076.

</details>

<details>
<summary>üìí Files selected for processing (7)</summary>

* `.trae/lrr_analysis/25_control.md` (3 hunks)
* `.trae/lrr_analysis/executive_summary.md` (1 hunks)
* `IMPLEMENTATION_ROADMAP.md` (2 hunks)
* `src/ti4/core/game_state.py` (8 hunks)
* `src/ti4/core/planet_card.py` (1 hunks)
* `src/ti4/core/strategy_cards/coordinator.py` (1 hunks)
* `tests/test_rule_25_control.py` (1 hunks)

</details>

<details>
<summary>üß∞ Additional context used</summary>

<details>
<summary>üß¨ Code graph analysis (2)</summary>

<details>
<summary>tests/test_rule_25_control.py (5)</summary><blockquote>

<details>
<summary>src/ti4/core/constants.py (1)</summary>

* `UnitType` (6-20)

</details>
<details>
<summary>src/ti4/core/game_state.py (8)</summary>

* `GameState` (34-1269)
* `gain_planet_control` (778-852)
* `get_player_planet_cards` (937-946)
* `is_planet_card_in_deck` (948-957)
* `has_control_token_on_planet` (967-977)
* `resolve_planet_control_change` (897-935)
* `lose_planet_control` (854-895)
* `get_planet_card_deck_size` (959-965)

</details>
<details>
<summary>src/ti4/core/planet.py (2)</summary>

* `Planet` (9-90)
* `place_unit` (24-26)

</details>
<details>
<summary>src/ti4/core/unit.py (1)</summary>

* `Unit` (10-191)

</details>
<details>
<summary>src/ti4/core/planet_card.py (1)</summary>

* `is_exhausted` (18-20)

</details>

</blockquote></details>
<details>
<summary>src/ti4/core/game_state.py (4)</summary><blockquote>

<details>
<summary>src/ti4/core/planet_card.py (3)</summary>

* `PlanetCard` (6-81)
* `is_exhausted` (18-20)
* `exhaust` (26-30)

</details>
<details>
<summary>src/ti4/core/planet.py (3)</summary>

* `is_exhausted` (33-35)
* `exhaust` (41-45)
* `set_control` (20-22)

</details>
<details>
<summary>src/ti4/core/objective.py (1)</summary>

* `Objective` (13-21)

</details>
<details>
<summary>src/ti4/core/strategy_cards/coordinator.py (4)</summary>

* `ready_strategy_card` (601-611)
* `ready_all_strategy_cards` (613-620)
* `get_player_strategy_card_assignments` (989-997)
* `get_exhausted_cards` (999-1010)

</details>

</blockquote></details>

</details>

</details>

<details>
<summary>üîá Additional comments (7)</summary><blockquote>

<details>
<summary>src/ti4/core/strategy_cards/coordinator.py (1)</summary><blockquote>

`999-1011`: **New helper `get_exhausted_cards()` is clear and correct.**

Iterates tracked states and returns exhausted set as expected.

</blockquote></details>
<details>
<summary>src/ti4/core/game_state.py (4)</summary><blockquote>

`85-91`: **Planet-control state containers added ‚Äî LGTM.**

Clear separation: deck, per-player hands, and control tokens.

---

`311-318`: **Propagation of planet-control fields in `_create_new_state` ‚Äî LGTM.**

Ensures immutability semantics are preserved.

---

`1158-1180`: **Coordinator sync looks correct.**

Assignment/exhaustion mirrored from coordinator; safe no-op guard included.

---

`979-1061`: **Nice helpers for planet-card and control-token ops.**

Clear, cohesive, and side-effect scoped.



Also applies to: 1063-1084

</blockquote></details>
<details>
<summary>.trae/lrr_analysis/25_control.md (1)</summary><blockquote>

`86-92`: **Missing tests claimed for Rule 25.6 ‚Äî add tests or update docs**

.thetrae/lrr_analysis/25_control.md (lines 86‚Äì92; also 120‚Äì133) claims a test `test_rule_25_6_control_loss_through_game_effects` and "additional integration tests", but tests/test_rule_25_control.py contains only tests for 25.1, 25.1a, 25.1b, 25.1c, 25.2, 25.3, 25.4, 25.5, and 25.7 ‚Äî 25.6 and the integration tests are missing. Add the missing tests or update the markdown to reflect current coverage.

</blockquote></details>
<details>
<summary>IMPLEMENTATION_ROADMAP.md (1)</summary><blockquote>

`11-12`: **Roadmap metrics mismatch ‚Äî verify Rule 25 tests/CI auto-sourcing**

rg returned 0 matches for ^def\s+test_rule_25_ in tests, but IMPLEMENTATION_ROADMAP.md (lines 18, 47) claims Rule 25 is 12/12 tests passing. Auto-source these metrics from CI or update the roadmap/test names/locations so automated checks can locate and verify them.

</blockquote></details>

</blockquote></details>

</details>

<!-- This is an auto-generated comment by CodeRabbit for review status -->

DETAILED COMMENTS:
----------------------------------------
Comment 1:
  File: .trae/lrr_analysis/executive_summary.md
  Line: 6
  Body: _‚ö†Ô∏è Potential issue_

<details>
<summary>üß© Analysis chain</summary>

**Inconsistent headline metrics (107/101 rules, 3.5%).**

These conflict with the roadmap (28.7%, many rules completed). Regenerate this summary from current sources or remove until automated.

---

üèÅ Script executed:

```shell
#!/bin/bash
# Quick sanity: detect obvious contradictions.
rg -n "Overall Implementation Progress|Total Rules Analyzed" .trae/lrr_analysis/executive_summary.md
rg -n "Overall Progress|Completed Rules" IMPLEMENTATION_ROADMAP.md
```

Length of output: 141

---



</details>

**Inconsistent headline metrics ‚Äî regenerate or remove executive summary**

.trae/lrr_analysis/executive_summary.md reports "Total Rules Analyzed: 107/101" and "Overall Implementation Progress: 3.5%"; IMPLEMENTATION_ROADMAP.md reports "Completed Rules: 28/101" and "Overall Progress: 28.7%". Regenerate the executive summary from current sources or remove it until the automation is corrected.

<!-- fingerprinting:phantom:medusa:chinchilla -->

<!-- This is an auto-generated comment by CodeRabbit -->

Comment 2:
  File: src/ti4/core/game_state.py
  Line: 7
  Body: _‚ö†Ô∏è Potential issue_

**Wrong type-checking import path for coordinator.**

Module lives under `strategy_cards/coordinator.py`. This breaks MyPy/IDE.

```diff
-    from .strategy_card_coordinator import StrategyCardCoordinator
+    from .strategy_cards.coordinator import StrategyCardCoordinator
```

<!-- suggestion_start -->

<details>
<summary>üìù Committable suggestion</summary>

> ‚ÄºÔ∏è **IMPORTANT**
> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.

```suggestion
    from .strategy_cards.coordinator import StrategyCardCoordinator
    from .system import System
```

</details>

<!-- suggestion_end -->

<details>
<summary>ü§ñ Prompt for AI Agents</summary>

```
In src/ti4/core/game_state.py around lines 16 to 17, the import path for
StrategyCardCoordinator is incorrect; update the import to reference the actual
module location by replacing the current import with from
..strategy_cards.coordinator import StrategyCardCoordinator (or the appropriate
relative path consistent with the package layout), ensure package __init__.py
files allow the relative import, run mypy/IDE recheck, and adjust any other
imports in the file to use the correct module path.
```

</details>

<!-- fingerprinting:phantom:medusa:chinchilla -->

<!-- This is an auto-generated comment by CodeRabbit -->

Comment 3:
  File: src/ti4/core/game_state.py
  Line: 248
  Body: _üõ†Ô∏è Refactor suggestion_

**Deterministic new controller selection when multiple players have units.**

Picking `next(iter(set))` is nondeterministic. Use initiative order or player list order.

```diff
-                if other_players_with_units:
+                if other_players_with_units:
                     # Lose control
                     new_state = self.lose_planet_control(current_controller, planet)

-                    # Rule 25.5a: Player with units gains control
-                    new_controller = next(
-                        iter(other_players_with_units)
-                    )  # Take first player
+                    # Rule 25.5a: Player with units gains control (deterministic)
+                    candidates = list(other_players_with_units)
+                    new_controller = self._sort_players_by_initiative_order(candidates)[0]
                     _, final_state = new_state.gain_planet_control(
                         new_controller, planet
                     )
                     return final_state
```


> Committable suggestion skipped: line range outside the PR's diff.

<!-- fingerprinting:phantom:medusa:chinchilla -->

<!-- This is an auto-generated comment by CodeRabbit -->

============================================================
